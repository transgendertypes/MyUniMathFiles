Require Import UniMath.Foundations.All.
Require Import UniMath.MoreFoundations.All.

(* There are more than one way to define a universe *)
(* A universe is a family of types. *)
Definition tarski_universe : UU :=
  âˆ‘ X : UU, X â†’ UU.
Definition tarski_universe_over (X : UU) := (X â†’ UU).
(* This version is often what one has in mind, but the former is useful! *) 
Definition Tarski_universe : UU :=
  âˆ‘ X : hSet, X â†’ UU.

(* A universe isa property of types *) 
Definition property_universe : UU := UU â†’ hProp.
(* A universe isa decidable property of types *) 
Definition decidable_universe : UU := UU â†’ bool.
(* A universe is a mapping from types to pointed types *)
(* The "point" indicates that the type is not in the universe *)
(* For instance, UU â†’ Nat is like a "multiset" of types*)
(* Geometrically, the nonzero elements of the classifying type classifies incidences *)
Definition classifying_universe : UU :=
  âˆ‘ X : UU, âˆ‘ zero : X, UU â†’ X.
Definition pointed : UU := âˆ‘ X : UU, X.
Notation "UU*" := pointed.
Definition pointed_to_UU : UU* â†’ UU := pr1.
Coercion pointed_to_UU : pointed >-> UU.
Definition base (X : pointed) : X := pr2 X.
Coercion base : pointed >-> pointed_to_UU.

(* This redefinition is fun, don't you agree? *)
Definition basepoint ( X : UU* ) : X := X.

Definition classifying_universe_over (X : UU*) := UU â†’ X.

Definition unital_classifying_universe : UU :=
  âˆ‘ ğ”˜ : classifying_universe ,
      âˆ x : (pr1 ğ”˜), x = x.

Definition hypertarski : UU := UU â†’ UU.

Definition UU_with_basepoint : UU*.
  exists UU. exact âˆ….
Defined.
Notation "UUâˆ…" := UU_with_basepoint.

(* The main definition *)
Inductive Universe : UU :=
| tarski     (X : UU) : tarski_universe_over X â†’ Universe
| propertied (X : UU*) : classifying_universe_over X â†’ Universe.
Axiom wedge : tarski UU = propertied UUâˆ….
(* The idea isthat Universe isthe wedge sum of the two notions of universe *)

Definition Universe_decomposition : Universe â†’ tarski_universe â¨¿ classifying_universe.
  intro.
  induction X.
  left; exists X; exact t.
  right; exists X. exists X. exact c.
Defined.

Definition Universal := UU â†’ UU.
(* \mbfU *)
Section Points.
Context (ğ” : Universal).
(* tarski points *)
Definition tpoints : UU :=
  âˆ‘ x : UU, ishinh (âˆ‘ y : UU, ğ” y = x).
(* incident points *)
Definition ipoints : UU :=
  âˆ‘ x : UU, ishinh ( ğ” x ).

(* Represents a "tarski" universe as an "incidence" universe *)
(* The "multiplicity" in tarski universes "counts" the redundancies*)
(* The "redundancy" is "dualized" into an incidence. *)
Definition dualize (tarski : Universal) : Universal.
  exact (Î» X, âˆ‘ y : UU, tarski y = X).
Defined.
Definition antidualize : Universal â†’ Universal.
  intros.
  exact (Î» x, âˆ‘ y : UU, X x = y).
Defined.

Definition encode {X : UU} : X â†’ UU.
  intro.
  exact ((X,, X0) = (X,, X0)).
Defined.

Definition codualize (incidence : Universal) : Universal.
  intro x.
  exact (âˆ‘ y : incidence x, encode y = x).
  Defined.
End Points.
(* â—’ \circlebottomhalfblack *)
(* â—“ \circletophalfblack *)
Notation "â—’" := dualize (at level 300). 
Notation "â—“" := codualize (at level 300). 

Section incidence.
Context (ğ” : Universal).
Definition ipoint : ipoints ğ” â†’ UU.
  exact pr1.
Defined.
Definition imultiplicity : ipoints ğ” â†’ UU.
  intro.
  exact (ğ” (pr1 X)).
Defined.

Definition tpoint : tpoints ğ” â†’ UU.
  exact pr1.
Defined
.
Definition tmultiplicity : tpoints ğ” â†’ UU.
  unfold tpoints.
  intro. induction X as [X _].
  exact (âˆ‘ y : UU, ğ” y = X).
Defined.

Definition iincidence : ipoints ğ” â†’ UU.
  intro.
  exact (ipoint X Ã— imultiplicity X).
Defined.
Definition tincidence : tpoints ğ” â†’ UU.
  intro.
  exact (tpoint X Ã— tmultiplicity X).
Defined.

End incidence.

Section incidences.
  Context (ğ” : Universal).
Definition iincidences := total2 (iincidence ğ”).
Definition tincidences := total2 (tincidence ğ”).
End incidences.

Theorem iintot_incidences {x : Universal} : tincidences x = iincidences (â—’ x).
  unfold tincidences, iincidences, dualize. unfold iincidence, tincidence.
  unfold tpoints, tpoint, tmultiplicity, ipoints, ipoint, imultiplicity.
  apply idpath.
Defined.
Theorem tintoi_adj {x : Universal} : tincidences x â†’ iincidences (â—’ x).
  rewrite iintot_incidences. apply idfun.
Defined.
Theorem iintot_adj_co {x : Universal} : iincidences x â†’ tincidences (â—“ x).
  rewrite iintot_incidences. unfold "â—“", "â—’".
  simpl. unfold iincidences, encode.
  unfold iincidence.
  unfold ipoints, ipoint, imultiplicity.
  intro.
  induction X.
  induction pr1.
  simpl in pr2.
  induction pr2.
  simpl.
  unfold ishinh_UU.
  simpl.
  refine ((_,, _),, _).
  simpl.
  split.
  Focus 2.
  exists pr1.
  Unshelve.
  Focus 2.
  exact (âˆ‘ y : x pr1, (encode y) = pr1).
  apply idpath.
  intro.
  intro.
  apply X.
  exists (pr1).
  apply idpath.
  Abort.
(* INTRO really don'trivial have the right definitions*)
Theorem iintot_adj {x : Universal} : iincidences x â†’ tincidences (antidualize x).
  unfold iincidences, tincidences, antidualize.
  unfold tincidence, iincidence, tpoints, tpoint, ipoints, ipoint.
  simpl.
  unfold ishinh_UU, tmultiplicity, imultiplicity.
  intro.
  induction X.
  induction pr1.
  simpl.
  induction pr2.
  simpl in pr2, pr3.
  refine (((âˆ‘ y :

 UU, x pr1 = y),, _ ),, _).
  simpl.
  split.
  Unshelve.
  Focus 2.
  exists pr1.
  Unshelve.
  Focus 1.
  apply idpath.
  exists (x pr1).
  apply idpath.
  intro.
  intro.
  apply pr0.
  intro.
  apply X.
  exists pr1.
  apply idpath.
Defined.

Notation "I â™¯" := (iintot_adj I) (at level 300).
Notation "T â™­" := (tintoi_adj T) (at level 300).
(*
Theorem tintoi_anti_incidences {x : Universal} : iincidences x <- tincidences x.
  unfold iincidences, tincidences, "â—“".
  unfold tincidence, iincidence, tpoints, tpoint, ipoints, ipoint.
  simpl.
  unfold ishinh_UU, tmultiplicity, imultiplicity.
  intro.
  induction X.
  induction pr1.
  simpl in pr2, pr0.
  induction pr2.
  induction pr3.
  rewrite <- pr4 in pr2.
  induction pr2.
  remember (pr2,, pr5).
  rewrite pr4 in t.
  rewrite pr4 in pr2.
  refine ((pr1,, _),, _).
  split.
  simpl.
  assumption.
  simpl.
  Unshelve. Focus 2.
  simpl.
*)

Theorem tintoi_points {x : Universal} : tpoints x = ipoints (â—’ x).
  unfold tpoints, ipoints, dualize. apply idpath.
Defined.
Theorem tintoi_point {x : Universal} : tpoint x = ipoint (â—’ x).
  apply idpath.
Defined.

Theorem iintot_incidence {x : Universal} : tincidence x = iincidence (â—’ x).
  apply idpath.
Defined.

Definition incidences0 := iincidences.
Definition incidences1 := tincidences.
Fixpoint incidences (n : nat) : Universal â†’ UU.
  induction n.
  - exact iincidences.
  - exact (incidences n âˆ˜ â—’). 
Defined.

Theorem incidence_levels_lower : âˆ n : nat,
          âˆ UtoU : Universal, 
      âˆ‘ lowered : Universal, incidences n lowered = incidences (S n) UtoU .
  intros.
  exists (â—’ UtoU).
  apply idpath.
Defined.
Fixpoint incidence_levels_flatten ( n : nat) : âˆ UtoU : Universal,
       âˆ‘ flattened : Universal, incidences 0 flattened = incidences n UtoU .
  intros.
  induction n.
  exists UtoU. apply idpath.
  remember (incidence_levels_lower n UtoU).
  induction t as[lowered equals].
  rewrite <- equals.
  exact (incidence_levels_flatten _ _).
Defined.
  
Section makers.
Context {ğ” : Universal}.
Definition make_ipoints {X : UU} (y : ğ” X) : ipoints ğ”.
  unfold ipoints.

  exists X. intro. intro. apply X0.
  exact y.
Defined.

Definition make_tpoints (Y : UU) : tpoints ğ”.
  refine (ğ” Y,, _).
  unfold ishinh.
  simpl.
  unfold ishinh_UU.
  intros.
  apply X.
  exists Y.
  apply idpath.
Defined.

Definition make_iincidence {X : UU} (x : X) (y : ğ” X) : iincidence ğ” (make_ipoints y).
  split. exact x.
  unfold imultiplicity, make_ipoints.
  exact y.
Defined.
Definition make_tincidence {X : UU} (x : X) (y : ğ” X) : tincidence ğ” (make_tpoints X).
  split. exact y.
  exists X.
  apply idpath.
Defined.

End makers.
  
                             


(* Axiom axiom_of_contractible_zero : (âˆ… = âˆ…) = unit. *)
Axiom axiom_of_universal_zero : (âˆ… = âˆ…) = UU.
(* of course, these two axioms are not well founded if we accept both. *)

Example constant0 : Universal := Î» X, âˆ….
(* The tarski perspective: constant0 isa (projetive?) universe with one "line",
the empty type, of multiplicity UU. *)
(* The incidence perspective: constant0 is a (affine?) universe with no "points"*)
Theorem whatijustsaid0 :
  ((tmultiplicity constant0 (make_tpoints âˆ…)) = (UU Ã— (âˆ… = âˆ…)))
                                                 Ã— (UU â†’ tpoints constant0)
Ã— ipoints constant0 = âˆ….
  split.
  - unfold tmultiplicity, constant0, make_tpoints.
    apply idpath.
  - split.
    + unfold tpoints, constant0.
      exists âˆ…. unfold ishinh, ishinh_UU. simpl.
      intro. intro. apply X0.
      exists X. apply idpath.
    + unfold ipoints.
      unfold constant0.
      apply univalence.
      unfold ishinh, ishinh_UU. simpl.
      apply weqtoempty.
      intro.
      induction X.
    pose proof (pr2 hfalse).
    apply X.
    intro.
    inversion X0.
  Defined.
    

(* The tarski perspective: constant1 isa (projective?) universe with one "line",
the unit type, of multiplicity UU. *)
(* The incidence perspective: constant1 is a curve passing through each type once*)
(* We can think of this as a curve without self intersection or "holes". *)
Example constant1 : Universal := Î» X, unit.

Theorem whatijustsaid1 :
  ((tmultiplicity constant1 (make_tpoints unit)) = (UU Ã— (unit = unit)))
                                                 Ã— (UU â†’ tpoints constant1)
Ã— ipoints constant1 = UU Ã— âˆ x : UU, imultiplicity constant1 (make_ipoints (tt : constant1 x))  = unit.
  split; try split.
  - intro. unfold tpoints, constant1. exists unit. unfold ishinh,ishinh_UU.
    simpl. intro. intro. apply X0.
    exists X. apply idpath.
  - split.
    + unfold ipoints, constant1.
      apply univalence.
      apply Equivalence_to_weq.
      unfold ishinh, ishinh_UU.
      simpl.
      exists pr1. unfold isEquivalence. exists (Î» x, (x,, Î» pp, Î» fnc, fnc tt)).
      simpl. exists idpath.
      simpl. unfold maponpaths. unfold paths_rect.  simpl.
      refine (pr1 _,, _).
      ++ intro.  
         Unshelve.
         Focus 2.
         intro.
         exact unit.
         Unshelve. Focus 2.
         refine (_,, tt).
         intro.
         induction x.
         simpl.
         apply total2_paths2.
         apply idpath.
         simpl.
         apply funextsec.
         unfold homot.
         intro.
         apply funextfun.
         unfold homot. intro.
         apply x.
         +++ simpl.
             induction (paths_rect (âˆ P : hProp, (unit â†’ P) â†’ P)
      (Î» (pp : hProp) (fnc : unit â†’ pp), fnc tt)
      (Î» (b2 : âˆ P : hProp, (unit â†’ P) â†’ P)
       (_ : (Î» (pp : hProp) (fnc : unit â†’ pp), fnc tt) = b2),
       pr1 x,, (Î» (pp : hProp) (fnc : unit â†’ pp), fnc tt) = pr1 x,, b2)
      (idpath (pr1 x,, (Î» (pp : hProp) (fnc : unit â†’ pp), fnc tt))) 
      (pr2 x)
      (funextsec (Î» t : hProp, (unit â†’ t) â†’ t)
         (Î» (pp : hProp) (fnc : unit â†’ pp), fnc tt) (pr2 x)
         (Î» x0 : hProp,
          funextfun (Î» fnc : unit â†’ x0, fnc tt) (pr2 x x0)
            (Î» x1 : unit â†’ x0, pr1 (pr2 x0 (x1 tt) (pr2 x x0 x1)))))).
             simpl.
             unfold paths_rect.
             induction x.
             unfold funextsec.
             unfold funextfun.
             simpl.
             unfold funextsecImplication.
             unfold isweqtoforallpaths.
             simpl.
             unfold invmap, make_weq.
             simpl.
             unfold hfiberpr1.
             unfold weqccontrhfiber.
             simpl.
             unfold iscontrpr1.
             unfold Preamble.pr1.
             induction 
         
      exists ((Î» x, unit,, Î» PP, Î» fnc, fnc PP)).
      