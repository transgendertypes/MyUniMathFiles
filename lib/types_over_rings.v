Require Import UniMath.Foundations.All.
Require Import UniMath.MoreFoundations.All.
Require Import UniMath.Algebra.All.
Require Import UniMath.NumberSystems.All.


(* To each point of a monoid (say a ring) we assign a type.*)
Definition typeon (ùîæ : UU) := ùîæ -> UU.
  
Check ‚Ñ§.

Example Fin : typeon hz.
unfold typeon.
intro x.
remember (hzabsval x) as absval. 
exact (stn absval).
Defined.

Example booland : binop boolset.
  unfold binop. 
  unfold boolset.
  simpl.
  exact andb.
Defined.

Lemma isassoc_booland : isassoc booland.
  unfold booland, isassoc.
  simpl.
  intros.
  induction x,x',x''; apply idpath.
Defined.

Lemma isunital_booland : isunital booland.
  exists true.
  unfold isunit,islunit,isrunit,booland;
  split; intros; induction x;
  apply idpath.
Defined.

Lemma iscomm_booland : iscomm booland.
  unfold booland, iscomm.
  simpl.
  intros.
  induction x,x'; apply idpath.
Defined.
Example boolor : binop boolset.
  unfold binop. 
  unfold boolset.
  simpl.
  exact orb.
Defined.

Lemma isassoc_boolor : isassoc boolor.
  unfold boolor, isassoc.
  simpl.
  intros.
  induction x,x',x''; apply idpath.
Defined.

Lemma isunital_boolor : isunital boolor.
  exists false.
 
 unfold isunit,islunit,isrunit,boolor;
  split; intros; induction x;
  apply idpath.




Defined.

Lemma iscomm_boolor : iscomm boolor.
  unfold boolor, iscomm.
  simpl.
  intros.
  induction x,x'; apply idpath.
Defined.

Definition xorb : bool -> bool -> bool.
  intros.
  induction X;
  induction X0.
  - exact true.
  - exact false.
  - exact false.
  - exact true.
Defined.

Example boolxor : binop boolset.
  unfold binop. 
  unfold boolset.
  simpl.
  exact xorb.



Defined.

Lemma isassoc_boolxor : isassoc boolxor.
  unfold boolxor, isassoc.
  simpl.
  intros.
  induction x,x',x''; apply idpath.
Defined.

Lemma isunital_boolxor : isunital boolxor.
  exists true.
  unfold isunit,islunit,isrunit,boolxor;
  split; intros; induction x;
  apply idpath.
Defined.

Lemma iscomm_boolxor : iscomm boolxor.
  unfold boolxor, iscomm.
  simpl.
  intros.
  induction x,x'; apply idpath.
Defined.

Example boolandmonoid : monoid.
  exists (boolset,, booland).
  exact (isassoc_booland,, isunital_booland).
Defined.
Example boolormonoid : monoid.
  exists (boolset,, boolor).
  exact (isassoc_boolor,, isunital_boolor).
Defined.

Example boolxorgr : gr.
exists (boolset,, boolxor).
unfold isgrop.
unfold ismonoidop.
exists (isassoc_boolxor,, isunital_boolxor).
unfold invstruct.
simpl.
exists (Œª x, x).
unfold isinv, booland, negb, unel_is.
unfold islinv, isrinv, andb. simpl.
split;
  intros; induction x; simpl;
  apply idpath.
Defined.

Example BoolXor : typeon boolxorgr.
unfold typeon. intros.
induction X.
- exact unit.
- exact ‚àÖ.
Defined.

Example BoolAnd : typeon boolandmonoid.
unfold typeon; intros.
induction X.
- exact unit.
- exact ‚àÖ.
Defined.

Example BoolOr : typeon boolormonoid.
unfold typeon; intros.
induction X.
- exact unit.
- exact ‚àÖ.
Defined.


(* sometimes its easier to define the opmaps in terms
of the zeromaps and invmaps. The opmaps are the primary construct *)
(* x * 0 -> x *)
Definition zeromaps {ùîæ : monoid} (on : typeon ùîæ) : UU :=
  ‚àè x : ùîæ, on x √ó (on (unel ùîæ)) -> on x.
(* x + 0 -> x *)
Definition zeromaps_co {ùîæ : monoid} (on : typeon ùîæ) : UU :=
  ‚àè x : ùîæ, on x ‚®ø (on (unel ùîæ)) -> on x.

(* x / x -> 1 *)
Definition invmaps {ùîæ: gr} (on : typeon ùîæ) : UU :=
  ‚àè x : ùîæ, (on x) √ó (on (grinv ùîæ x)) -> on (unel ùîæ).
(* x - x -> 0 *)
Definition invmaps_co {ùîæ: gr} (on : typeon ùîæ) : UU :=
  ‚àè x : ùîæ, (on x) ‚®ø (on (grinv ùîæ x)) -> on (unel ùîæ).

(* x + y = z *)
Definition opmaps {ùîæ: monoid} (on : typeon ùîæ) : UU :=
  ‚àè x y : ùîæ, (on x) √ó (on y) -> on (op x y).
Definition opmaps_co {ùîæ: monoid} (on : typeon ùîæ) : UU :=
  ‚àè x y : ùîæ, (on x) ‚®ø (on y) -> on (op x y).
  
Example xormaps : opmaps BoolXor.
unfold opmaps, BoolXor.
intros.
induction x,y; simpl.
- exact tt.
- inversion X.
  exact pr2.
- inversion X.
  exact pr1.
- exact tt.
Defined.

Definition andmaps : opmaps BoolAnd.
  unfold opmaps, BoolAnd.
  simpl; intros.
  induction x,y; simpl; simpl in X.
  - exact tt.
  - exact (pr2 X).
  - exact (pr1 X).
  - exact (pr1 X).
Defined.

(* notice that the proofs of ormaps and ormaps_co are identical, even though
the statements are far from identical *)
Definition ormaps : opmaps BoolOr.
  unfold opmaps, BoolOr. simpl. intros.
  induction x,y; simpl in X; simpl; try exact tt.
  induction X; assumption.
Defined.

Definition ormaps_co : opmaps_co BoolOr.
  unfold opmaps_co, BoolOr. simpl. intros.
  induction x,y; simpl in X; simpl; try exact tt.
  induction X; assumption.
Defined.

Definition isabmonoidop_boolor : isabmonoidop boolor.
  exact ( (isassoc_boolor,, isunital_boolor),, iscomm_boolor).
Defined.

Definition abmonoid_boolor : abmonoid.
  exists (boolset,, boolor).
  exact isabmonoidop_boolor.
Defined.

Definition isabmonoidop_boolxor : isabmonoidop boolxor.
  exact ( (isassoc_boolxor,, isunital_boolxor),, iscomm_boolxor).
Defined.
  
Definition abmonoid_boolxor : abmonoid.
  exists (boolset,, boolxor).
  exact isabmonoidop_boolxor.
Defined.

Definition ismonoidop_booland : ismonoidop booland.
  exact (isassoc_booland,, isunital_booland).
Defined.
Definition isabmonoidop_booland : isabmonoidop booland.
  exact ( ismonoidop_booland,, iscomm_booland).
Defined.

Definition abmonoid_booland : abmonoid.
  exists (boolset,, booland).
  exact isabmonoidop_booland.
Defined.

Definition boolrig : rig.
  unfold rig.
  exists (boolset,, boolor,, booland).
  unfold isrigops.
  split.
- unfold op1,op2.
  simpl.
  exists (isabmonoidop_boolor ,, ismonoidop_booland).
  split;
  intros;
  induction x; unfold unel_is ; apply idpath.
- unfold isdistr.
  unfold op1,op2, isrdistr, isldistr.
  simpl.
  split;
  intros;
  induction x,x',x'';
  apply idpath.
Defined.

Definition typedrig : UU :=
  ‚àë rr : rig,
      ‚àë on : typeon rr,
        ‚àè x y : rr,
          ((on x ‚®ø on y) -> on (op1 x y))
            √ó ((on x √ó on y) -> on (op2 x y)).

Definition cotypedrig : UU :=
  ‚àë rr : rig,
      ‚àë on : typeon rr,
        ‚àè x y : rr,
          ((on x ‚®ø on y) <- on (op1 x y))
            √ó ((on x √ó on y) <- on (op2 x y)).

Definition beautifulrig : UU :=
  ‚àë rr : rig,
      ‚àë on : typeon rr,
        ‚àè x y : rr,
          ((on x ‚®ø on y) -> on (op1 x y))
        √ó ((on x √ó on y) <- on (op2 x y)).
Definition beautifulrig_torig : beautifulrig -> rig.
  exact pr1. Defined.
Coercion beautifulrig_torig : beautifulrig >-> rig.

Definition beautifulring : UU :=
  ‚àë rr : ring,
      ‚àë on : typeon rr,
        ‚àè x y : rr,
          ((on x ‚®ø on y) -> on (op1 x y))
        √ó ((on x √ó on y) <- on (op2 x y)).

Definition beautifulring_to_beautifulrig :
  beautifulring -> beautifulrig.
  intros.
  exists (pr1 X). exact (pr2 X).
Defined.
Coercion beautifulring_to_beautifulrig : beautifulring >-> beautifulrig.

Definition beautifulcommring : UU :=
  ‚àë rr : commring,
      ‚àë on : typeon rr,
        ‚àè x y : rr,
          ((on x ‚®ø on y) -> on (op1 x y))
        √ó ((on x √ó on y) <- on (op2 x y)).

Definition beautifulcommring_to_beautifulring :
  beautifulcommring -> beautifulring.
  intros.
  exists (pr1 X). exact (pr2 X).
Defined.
Coercion beautifulcommring_to_beautifulring : beautifulcommring >-> beautifulring.

Definition uglyrig : UU :=
  ‚àë rr : rig,
      ‚àë on : typeon rr,
        ‚àè x y : rr,
          ((on x ‚®ø on y) -> on (op1 x y))
        √ó ((on x √ó on y) <- on (op2 x y)).
  
(* Our path type "ring" is  a nice example of charm ring
  (a = b) √ó (c = d) -> (a + c = b + d)
  (a = b) ‚®ø (c = d) -> (ac + bd = ad + bc)
(a-b)+(c-d) = a+c-b-d
(a-b)(c-d)=ac-ad-bc+bd
 *)

Definition charmrig : UU :=
  ‚àë rr : rig,
      ‚àë on : typeon rr,
        ‚àè x y : rr,
          ((on x ‚®ø on y) -> on (op2 x y))
        √ó ((on x √ó on y) -> on (op1 x y)).
  

Definition typedring : UU :=
  ‚àë rr : ring,
      ‚àë on : typeon rr,
        ‚àè x y : rr,
          ((on x ‚®ø on y) -> on (op1 x y))
            √ó ((on x √ó on y) -> on (op2 x y)).
Definition typedring_to_typedrig : typedring -> typedrig.
  intros;induction X.
  exists pr1;exact pr2.
Defined.
Coercion typedring_to_typedrig : typedring >-> typedrig.

Definition typedring_co : UU :=
  ‚àë rr : ring,
      ‚àë on : typeon rr,
        ‚àè x y : rr,
          ((on x ‚®ø on y) <- on (op1 x y))
            √ó ((on x √ó on y) <- on (op2 x y)).

Definition typedring_co_to_typedrig_co : typedring -> typedrig.
  intros;induction X.
  exists pr1;exact pr2.
Defined.
Coercion typedring_co_to_typedrig_co : typedring >-> typedrig.

Definition commtypedring : UU :=
  ‚àë rr : commring,
      ‚àë on : typeon rr,
        ‚àè x y : rr,
          ((on x ‚®ø on y) -> on (op1 x y))
            √ó ((on x √ó on y) -> on (op2 x y)).
Definition commtypedring_to_typedring : commtypedring -> typedring.
  intros;induction X.
  exists pr1;exact pr2.
Defined.
Coercion commtypedring_to_typedring
  : commtypedring >-> typedring.

Definition commtypedring_co : UU :=
  ‚àë rr : commring,
      ‚àë on : typeon rr,
        ‚àè x y : rr,
          ((on x ‚®ø on y) <- on (op1 x y))
            √ó ((on x √ó on y) <- on (op2 x y)).

Definition commtypedring_co_to_typedring_co : commtypedring_co -> typedring_co.
  intros;induction X.
  exists pr1;exact pr2.
Defined.
Coercion commtypedring_co_to_typedring_co
  : commtypedring_co >-> typedring_co.

Definition weqtypedrig : UU :=
  ‚àë rr : rig,
      ‚àë on : typeon rr,
        ‚àè x y : rr,
          (weq (on x ‚®ø on y)  (on (op1 x y)))
            √ó (weq (on x √ó on y)  (on (op2 x y))).

Definition pathtypedrig : UU :=
  ‚àë rr : rig,
      ‚àë on : typeon rr,
        ‚àè x y : rr,
          ( (on x ‚®ø on y) = (on (op1 x y)))
        √ó ((on x √ó on y) = (on (op2 x y))).

Definition therig (rr : typedrig) : rig.
  induction rr.
  exact pr1.
Defined.
Coercion therig : typedrig >-> rig.

Definition on (rr : typedrig) : rr -> UU.
  induction rr.
  induction pr2.
  exact pr0.
Defined.

Coercion on : typedrig >-> Funclass.

Definition thetype {r : typedrig} (rr : r) : UU.
  exact (r rr).
Defined.

Definition function_on_the_sum {r : typedrig} (x y : r)
  : (thetype x) ‚®ø (thetype y) -> thetype (op1 x y).
  induction r. induction pr2.
  exact (Preamble.pr1 (pr2 x y)).
Defined.
Notation "x ‚®• y" := (function_on_the_sum x y) (at level 300).

Definition function_on_the_product {r : typedrig} (x y : r)
  : (thetype x) √ó (thetype y) -> thetype (op2 x y).
  induction r. induction pr2.
  exact (Preamble.pr2 (pr2 x y)).
Defined.
Notation "x ‚®± y" := (function_on_the_product x y) (at level 300).

Definition functiontypes_from (‚Ñµ : UU) : UU -> UU.
  intros.
  exact (‚Ñµ -> X).
Defined.
Definition functiontypes_to (‚Ñ∂ : UU) : UU -> UU.
  intros.
  exact (X -> ‚Ñ∂).
Defined.
Definition rigof_functiontypes_from (‚Ñµ : UU) : typedrig -> typedrig.
  unfold typedrig.
  intros.
  induction X as [therig therest].
  induction therest as [on therest].
  exists therig.
  exists (functiontypes_from ‚Ñµ ‚àò on).
  intros. unfold functiontypes_from.
  simpl.
  remember (therest x y).
  induction d as [adding multiplying].
  clear Heqd. clear therest.
  split.
  - clear multiplying.
    intro either. intro aleph.
    induction either.
    + exact (adding (inl (a aleph))).
    + exact (adding (inr (b aleph))).
  - clear adding.
    intro both. intro aleph.
    induction both as [north south].
    remember (north aleph) as northpole.
    remember (south aleph) as southpole.
    exact (multiplying (northpole,, southpole)).
Defined.

Definition rigof_pathtypes : typedrig -> typedrig.
  unfold typedrig.
  intros.
  induction X as [therig therest].
  induction therest as [on therest].
  exists therig.
  exists ((Œª x, x = x) ‚àò on).
  simpl.
  intros.
  split.
  intros.
  apply idpath.
  intros.
  apply idpath.
Defined.

Definition corigof_pathtypes : typedrig -> cotypedrig.
  unfold typedrig, cotypedrig.
  intros.
  induction X as [therig therest].
  induction therest as [on therest].
  exists therig.
  exists ((Œª x, x = x) ‚àò on).
  simpl.
  intros.
  split; intros.
  left; apply idpath.
  split; apply idpath.
Defined.

Definition zero {R  : rig} : R .
  induction R.
  induction pr1.
  induction pr0.
  induction pr2.
  induction pr2.
  induction pr5.
  simpl.
  refine (unel ((pr1,, _),,  _)).
  exact (Preamble.pr2 pr2).
Defined.

Definition one {R  : rig} : R .
  induction R.
  induction pr1.
  induction pr0.
  induction pr2.
  induction pr2.
  induction pr5.
  simpl.
  refine (unel ((pr1,, _),, _)).
  exact (Preamble.pr1 pr2).
Defined.

Definition zerotype ( R : typedrig ) : UU :=
  thetype (zero : R).
Definition onetype ( R : typedrig ) : UU :=
  thetype (one : R ).

Definition iszeroempty ( R : typedrig ) : UU :=
  zerotype R = ‚àÖ.
Definition iszerounit ( R : typedrig ) : UU :=
  zerotype R = unit.
Definition isoneempty ( R : typedrig ) : UU :=
  onetype R = ‚àÖ.
Definition isoneunit ( R : typedrig ) : UU :=
  onetype R = unit.

(* cation and anion are just arbitrary notation *)
Definition iscation ( R : typedrig ) : UU :=
  iszeroempty R √ó isoneunit R .
Definition isanion ( R : typedrig ) : UU :=
  iszerounit R √ó isoneempty R .
Definition isneutral ( R : typedrig ) : UU :=
  zerotype R = onetype R. 

(* *)
Definition istypedrigconstant ( R : typedrig ) : UU :=
  ‚àë ‚Ñµ : UU,
      ‚àè rr : R,
        thetype rr = ‚Ñµ.
  
Lemma isaconstant_neutral {ùï£} : istypedrigconstant ùï£ -> isneutral ùï£.
  unfold istypedrigconstant,isneutral.
  intros.
  induction X.
  pose proof (pr2 zero).
  unfold zerotype,onetype.
  rewrite X.
  symmetry. exact (pr2 one).
Defined.

Notation ‚Ñ¶ := thetype.

Definition theimage_oversum {ùï£ : typedrig}
  (x y : ùï£)
  (xy : ‚Ñ¶ x ‚®ø ‚Ñ¶ y)
  := (x ‚®• y) xy.

Definition theimage_overprod {ùï£ : typedrig}
  (x y : ùï£)
  (xy : ‚Ñ¶ x √ó ‚Ñ¶ y)
  := (x ‚®± y) xy.

Definition mixed_sum_r {ùï£ : typedrig}
  {x : ùï£}
  (xx : ‚Ñ¶ x)
  (y : ùï£): ‚Ñ¶ (x + y)%ring
  := (x ‚®• y) (inl xx : ‚Ñ¶ x ‚®ø ‚Ñ¶ y).
Definition mixed_sum_l {ùï£ : typedrig}
  {y : ùï£}
  (x : ùï£)
  (yy : ‚Ñ¶ y) : ‚Ñ¶ (x + y)%ring
  := (x ‚®• y) (inr yy : ‚Ñ¶ x ‚®ø ‚Ñ¶ y).

Definition internal_mult {ùï£ : typedrig}
  {x y : ùï£}
  (xx : ‚Ñ¶ x)
  (yy : ‚Ñ¶ y): ‚Ñ¶ (x * y)%ring
  := (x ‚®± y) (xx,,yy).

Notation "xx ‚ßù yy" := (internal_mult xx yy) (at level 250).
Notation "xx ‚ü¥ y" := (mixed_sum_r xx y) (at level 250). 
Notation "x ‚¨≤ yy" := (mixed_sum_l x yy) (at level 250). 

Definition internal_mult3_l {ùï£: typedrig}  
  {x y z : ùï£}
  (xx : ‚Ñ¶ x)
  (yy : ‚Ñ¶ y)
  (zz : ‚Ñ¶ z): ‚Ñ¶ (x * (y * z): ùï£)%ring
  := (xx ‚ßù (yy ‚ßù zz)).

Definition internal_mult3_r {ùï£: typedrig}  
  {x y z : ùï£}
  (xx : ‚Ñ¶ x)
  (yy : ‚Ñ¶ y)
  (zz : ‚Ñ¶ z): ‚Ñ¶ (x * y * z : ùï£)%ring
  := ((xx ‚ßù yy) ‚ßù zz).

Lemma types_assoc_prod (ùï£ : typedrig) :
  ‚àè x y z : ùï£,
      ‚Ñ¶ (x * y * z)%ring = ‚Ñ¶ (x * (y * z))%ring .
  intros.
  induction ùï£.
  induction pr1.
  induction pr2.
  simpl in x,y,z.
  simpl in pr2.
  unfold isrigops in pr0.
  induction pr0.
  induction pr0.
  induction pr0.
  induction pr6.
  pose proof (pr6 x y z).
  unfold op2.
  unfold op2 in X.
  simpl. simpl in X.
  rewrite X.
  apply idpath.
Defined.

Lemma types_assoc_sum (ùï£ : typedrig) :
  ‚àè x y z : ùï£,
      ‚Ñ¶ (x + y + z)%ring = ‚Ñ¶ (x + (y + z))%ring .
  intros.
  induction ùï£.
  induction pr1.
  induction pr2.
  simpl in x,y,z.
  simpl in pr2.
  unfold isrigops in pr0.
  induction pr0.
  induction pr0.
  induction pr0.
  induction pr0.
  induction pr0.
  pose proof (pr0 x y z).
  simpl. simpl in X.
  rewrite X.
  apply idpath.
Defined.

Definition assoc_prod_on_types {ùï£ : typedrig} {x y z : ùï£}
      : ‚Ñ¶ (x * y * z : ùï£)%ring -> ‚Ñ¶ (x * (y * z) : ùï£)%ring .
  intros. rewrite types_assoc_prod in X.
  exact X.
Defined.
Definition assoc_prod_on_types' {ùï£ : typedrig} {x y z : ùï£}
      : ‚Ñ¶ (x * y * z : ùï£)%ring <- ‚Ñ¶ (x * (y * z) : ùï£)%ring .
  intros. rewrite <- types_assoc_prod in X.
  exact X.
Defined.

Definition assoc_sum_on_types {ùï£ : typedrig} {x y z : ùï£}
      : ‚Ñ¶ (x + y + z : ùï£)%ring -> ‚Ñ¶ (x + (y + z) : ùï£)%ring .
  intros. rewrite types_assoc_sum in X.
  exact X.
Defined.

Definition assoc_sum_on_types' {ùï£ : typedrig} {x y z : ùï£}
      : ‚Ñ¶ (x + y + z : ùï£)%ring <- ‚Ñ¶ (x + (y + z) : ùï£)%ring .
  intros. rewrite <- types_assoc_sum in X.
  exact X.
Defined.

Definition isinternal_assoc_prod (ùï£ : typedrig) : UU :=
  ‚àè x y z : ùï£,
      ‚àè xx : ‚Ñ¶ x, ‚àè yy : ‚Ñ¶ y, ‚àè zz : ‚Ñ¶ z,
       internal_mult3_l xx yy zz =
       assoc_prod_on_types ( 
        internal_mult3_r xx yy zz).

Definition isinternal_assoc_sum_rr (ùï£ : typedrig) : UU :=
  ‚àè x y z : ùï£,
      ‚àè xx : ‚Ñ¶ x,
       assoc_sum_on_types ( 
       (xx ‚ü¥ y) ‚ü¥ z) =
       (xx ‚ü¥ (y + z)%ring).

Definition isinternal_assoc_sum_lr (ùï£ : typedrig) : UU :=
  ‚àè x y z : ùï£,
      ‚àè yy : ‚Ñ¶ y,
       assoc_sum_on_types ( 
       (x ‚¨≤ yy) ‚ü¥ z) =
       (x ‚¨≤ (yy ‚ü¥ z)).
Definition isinternal_assoc_sum_ll (ùï£ : typedrig) : UU :=
  ‚àè x y z : ùï£,
      ‚àè zz : ‚Ñ¶ y,
       assoc_sum_on_types ( 
       (x + y)%ring ‚¨≤ zz) =
       (x ‚¨≤ (y ‚¨≤ zz)).
Definition isinternal_assoc_sum (ùï£ : typedrig) : UU :=
  isinternal_assoc_sum_ll ùï£
√ó isinternal_assoc_sum_lr ùï£
√ó isinternal_assoc_sum_rr ùï£.

Definition isfullyassoc (ùï£ : typedrig) : UU :=
  isinternal_assoc_sum ùï£
√ó isinternal_assoc_prod ùï£.

Lemma types_commute_sum {ùï£ : typedrig} :
  ‚àè x y : ùï£,
      ‚Ñ¶ (x + y)%ring = ‚Ñ¶ (y + x)%ring .
  intros.
  induction ùï£.
  induction pr1.
  induction pr2.
  simpl in x,y.
  simpl in pr2.
  unfold isrigops in pr0.
  induction pr0.
  induction pr0.
  induction pr0.
  induction pr0.
  pose proof (pr7 x y).
  unfold op1.
  unfold op1 in X.
  simpl. simpl in X.
  rewrite X.
  apply idpath.
Defined.

Lemma types_commute_prod {ùï£ : commtypedring} :
  ‚àè x y : ùï£,
      ‚Ñ¶ (x * y)%ring = ‚Ñ¶ (y * x)%ring .
  intros.
  induction ùï£.
  induction pr1.
  induction pr2.
  simpl in x,y.
  simpl in pr2.
  unfold isrigops in pr0.
  induction pr0.
  induction pr0.
  pose proof (pr4 x y).
  unfold op1.
  unfold op1 in X.
  simpl. simpl in X.
  rewrite X.
  apply idpath.
Defined.

Definition comm_sum_on_types {ùï£ : typedrig} {x y : ùï£}
      : ‚Ñ¶ (x + y : ùï£)%ring -> ‚Ñ¶ (y + x : ùï£)%ring .
  intros. rewrite (types_commute_sum x y) in X.
  exact X.
Defined.

Definition comm_prod_on_types {ùï£ : commtypedring} {x y : ùï£}
      : ‚Ñ¶ (x * y : ùï£)%ring -> ‚Ñ¶ (y * x : ùï£)%ring .
  intros. rewrite (types_commute_prod x y) in X.
  exact X.
Defined.

Definition isinternal_comm_sum (ùï£ : typedrig) : UU :=
  ‚àè x y : ùï£,
      ‚àè xx : ‚Ñ¶ x,
       (y ‚¨≤ xx) =
       comm_sum_on_types( 
        xx ‚ü¥ y).

Definition isinternal_comm_prod ( ùï£ : commtypedring ) : UU :=
  ‚àè x y : ùï£,
      ‚àè xx : ‚Ñ¶ x, ‚àè yy : ‚Ñ¶ y,
       (xx ‚ßù yy) =
       comm_prod_on_types( 
        yy ‚ßù xx).

Lemma types_distr_l {ùï£ : typedrig} :
  ‚àè x y z : ùï£,
      ‚Ñ¶ (x * (y + z))%ring = ‚Ñ¶ (x * y + x * z)%ring .
intros.
induction ùï£ as [rig [on rest]].
induction rig.
induction pr1 as [set [plus times]].
simpl in on.
induction pr2.
rename pr2 into distr.
unfold isdistr in distr.
induction distr as [ldistr rdistr].
remember (ldistr y z x).
unfold op1, op2.
unfold op1, op2 in p.
simpl. simpl in p.
rewrite p;apply idpath.
Defined.

Lemma types_distr_r {ùï£ : typedrig} :
  ‚àè x y z : ùï£,
      ‚Ñ¶ ((y + z) * x)%ring = ‚Ñ¶ (y * x + z * x)%ring .
intros.
induction ùï£ as [rig [on rest]].
induction rig.
induction pr1 as [set [plus times]].
simpl in on.
induction pr2.
rename pr2 into distr.
unfold isdistr in distr.
induction distr as [ldistr rdistr].
remember (rdistr y z x).
unfold op1, op2.
unfold op1, op2 in p.
simpl; simpl in p.
rewrite p;apply idpath.
Defined.

Definition distr_l_on_types {ùï£ : typedrig} {x y z : ùï£}
      : ‚Ñ¶ ((x * y) + (x * z) : ùï£)%ring <- ‚Ñ¶ (x * (y + z) : ùï£)%ring .
  intros. rewrite (types_distr_l x y) in X.
  exact X.
Defined.
Definition distr_r_on_types {ùï£ : typedrig} {x y z : ùï£}
      : ‚Ñ¶ ((y * x) + (z * x) : ùï£)%ring <- ‚Ñ¶ ((y + z) * x : ùï£)%ring .
  intros. rewrite (types_distr_r x y) in X.
  exact X.
Defined.

Definition isinternal_distr_l_l (ùï£ : typedrig) : UU :=
  ‚àè x y z : ùï£,
      ‚àè xx : ‚Ñ¶ x, ‚àè yy : ‚Ñ¶ y,
       distr_l_on_types 
       (xx ‚ßù (z ‚¨≤ yy)) =
        ((x * z)%ring ‚¨≤ (xx ‚ßù yy)) .

Definition isinternal_distr_l_r (ùï£ : typedrig) : UU :=
  ‚àè x y z : ùï£,
      ‚àè xx : ‚Ñ¶ x, ‚àè yy : ‚Ñ¶ y,
       distr_l_on_types 
       (xx ‚ßù (yy ‚ü¥ z)) =
        ((xx ‚ßù yy) ‚ü¥ (x * z)%ring) .

Definition isinternal_distr_r_r (ùï£ : typedrig) : UU :=
  ‚àè x y z : ùï£,
      ‚àè xx : ‚Ñ¶ x, ‚àè yy : ‚Ñ¶ y,
       distr_r_on_types 
       ((yy ‚ü¥ z) ‚ßù xx) =
        ((yy ‚ßù xx) ‚ü¥ (z * x)%ring) .

Definition isinternal_distr_r_l (ùï£ : typedrig) : UU :=
  ‚àè x y z : ùï£,
      ‚àè xx : ‚Ñ¶ x, ‚àè yy : ‚Ñ¶ y,
       distr_r_on_types 
       ((z ‚¨≤ yy) ‚ßù xx) =
         ( (z * x)%ring  ‚¨≤ (yy ‚ßù xx)) .

Definition isinternal_distr_r (ùï£ : typedrig) : UU :=
  isinternal_distr_r_r ùï£ 
                       √ó 
  isinternal_distr_r_l ùï£. 


Definition isinternal_distr_l (ùï£ : typedrig) : UU :=
  isinternal_distr_l_r ùï£ 
                       √ó 
  isinternal_distr_l_l ùï£. 

Definition isinternal_distr (ùï£ : typedrig) : UU :=
  isinternal_distr_l ùï£ √ó isinternal_distr_r ùï£.

Definition spacedrig : UU :=
  ‚àë œ° : typedrig,
      isfullyassoc œ° 
    √ó isinternal_comm_sum œ°
    √ó isinternal_distr œ°.

Definition spacedring : UU :=
  ‚àë œ° : typedring,
      isfullyassoc œ° 
    √ó isinternal_distr œ°
    √ó isinternal_comm_sum œ°.

Definition spacedcommring : UU :=
  ‚àë œ° : commtypedring,
      isfullyassoc œ° 
    √ó isinternal_distr œ°
    √ó isinternal_comm_sum œ°
    √ó isinternal_comm_prod œ°.

(* I think this is the "true" definition, with the arrows on the sum opposite the arrows on the product 
Definition beautyrig : UU :=
  ‚àë œ° : beautifulrig,
      isfullyassoc œ° 
    √ó isinternal_comm_sum œ°
    √ó isinternal_distr œ°.
*)

Example unittypedrig (‚Ñú : rig) : typedrig.
  intros.
  exists ‚Ñú.
  exists (Œª _, unit).
  intros.
  split; exact (Œª _, tt).
Defined.

Example constanttypedrig_left (‚Ñú : rig) (Points : UU) : typedrig.
  intros.
  exists ‚Ñú.
  exists (Œª _, Points).
  intros.
  split.
  + intro either; induction either.
    - exact a.
    - exact b.
  + exact pr1.
Defined.
Example constanttypedrig_right (‚Ñú : rig) (Points : UU) : typedrig.
  intros.
  exists ‚Ñú.
  exists (Œª _, Points).
  intros.
  split.
  + intro either; induction either.
    - exact a.
    - exact b.
  + exact pr2.
Defined.

Example unitspacedrig (‚Ñú : rig) : spacedrig.
exists (unittypedrig ‚Ñú).
    induction ‚Ñú as[theset [rest distr]].
    induction rest as[axs rest].
    induction axs as[sum product].
    induction sum as[summonoid sumcommutes].
    induction summonoid as[assocsum unitalsum].
    induction product as[assocprod unitalprod].
    simpl in rest.
split. unfold isfullyassoc.
- unfold isinternal_assoc_sum, isinternal_assoc_prod, unittypedrig.
  split.
  -- split.
  + unfold isinternal_assoc_sum_ll.
    intros.
    simpl in x,y,z.
    unfold thetype in zz.
    simpl in zz.
    unfold mixed_sum_l.
    unfold function_on_the_sum.
    simpl.
    unfold assoc_sum_on_types.
    unfold types_assoc_sum.
    unfold internal_paths_rew.
    unfold internal_paths_rew_r.
    simpl.
    unfold thetype.
    simpl.
    unfold isassoc in assocsum.
    simpl.
    induction (assocsum x y y).
    apply idpath.
  + simpl. split.
    ++ 
       unfold isinternal_assoc_sum_lr.
       intros.
       unfold thetype in yy.
       simpl in x,y,z,yy.
       unfold assoc_sum_on_types.
       unfold thetype.
       unfold internal_paths_rew.
       unfold types_assoc_sum.
       unfold internal_paths_rew_r.
       induction (assocsum x y z).
       apply idpath.
    ++  unfold isinternal_assoc_sum_rr.
        intros.
        unfold thetype in xx.
       simpl in x,y,z,xx.
       unfold assoc_sum_on_types.
       unfold thetype.
       unfold internal_paths_rew.
       unfold types_assoc_sum.
       unfold internal_paths_rew_r.
       induction (assocsum x y z).
       unfold mixed_sum_r.
       unfold function_on_the_sum.
       simpl.
       exact (idpath tt).
    -- intros.
       unfold internal_mult3_l.
       unfold internal_mult3_r.
       unfold assoc_prod_on_types.
       simpl.
       unfold internal_paths_rew.
       unfold types_assoc_prod.
       simpl. unfold internal_paths_rew_r.
       induction (assocprod x y z).
       unfold internal_mult.
       unfold function_on_the_product.
       simpl.
       exact (idpath tt).
- split.
  + unfold isinternal_comm_sum.
    intros.
    unfold comm_sum_on_types.
    unfold internal_paths_rew.
    unfold types_commute_sum.
    unfold internal_paths_rew_r.
    simpl.
    induction (sumcommutes x y).
    unfold mixed_sum_l,mixed_sum_r.
    unfold function_on_the_sum.
    simpl.
    exact (idpath tt).
  + induction distr as [ldistr rdistr].
    unfold isinternal_distr.
    split.
    -- unfold isinternal_distr_l.
       split.
       ++ unfold isinternal_distr_l_r.
          intros.
          unfold distr_l_on_types.
          unfold internal_paths_rew.
          unfold types_distr_l.
          unfold internal_paths_rew_r.
          simpl.
          unfold thetype.
          simpl.
          induction (ldistr y z x).
          unfold mixed_sum_r,internal_mult.
          unfold function_on_the_product, function_on_the_sum.
          simpl.
          exact (idpath tt).
       ++ unfold isinternal_distr_l_l.
          intros.
          unfold distr_l_on_types.
          unfold internal_paths_rew.
          unfold types_distr_l.
          simpl.
          unfold internal_paths_rew_r.
          simpl.
          induction (ldistr z y x).
          unfold mixed_sum_l.
          unfold internal_mult.
          unfold function_on_the_product, function_on_the_sum.
          simpl.
          exact (idpath tt).
       -- (*finally, *)
         unfold isinternal_distr_r.
         unfold isinternal_distr_r_r.
         unfold isinternal_distr_r_l.
         unfold internal_paths_rew.
         simpl.
         unfold distr_r_on_types.
         unfold internal_paths_rew.
         unfold types_distr_r.
         unfold internal_paths_rew_r.
         unfold thetype.
         simpl.
         split; intros;
         induction (rdistr y z x);
         induction (rdistr z y x);
         simpl;
           unfold mixed_sum_r , mixed_sum_l,internal_mult;
           unfold function_on_the_sum, function_on_the_product;
           exact (idpath tt).
Defined.


Example constantspacedrig_left (‚Ñú : rig) (Points : UU) : spacedrig.
  exists (constanttypedrig_left ‚Ñú Points).
    induction ‚Ñú as[theset [rest distr]].
    induction rest as[axs rest].
    induction axs as[sum product].
    induction sum as[summonoid sumcommutes].
    induction summonoid as[assocsum unitalsum].
    induction product as[assocprod unitalprod].
    simpl in rest.

  split.
  - split.
    + split;
         unfold isinternal_assoc_sum_ll;
         unfold isinternal_assoc_sum_lr;
         intros;
         unfold assoc_sum_on_types;
         unfold internal_paths_rew;
         unfold types_assoc_sum;
         simpl;
        unfold internal_paths_rew_r.
      -- induction assocsum.
         unfold mixed_sum_l.
         unfold function_on_the_sum.
         simpl.
         exact (idpath zz).
      -- intros. split.
            ++ intros. induction assocsum.
            unfold mixed_sum_l,mixed_sum_r.
            unfold function_on_the_sum.
            simpl.
            exact (idpath yy).
            ++ unfold isinternal_assoc_sum_rr.
            intros.
            unfold assoc_sum_on_types.
            unfold internal_paths_rew;
            unfold types_assoc_sum;
            simpl;
            unfold internal_paths_rew_r.
            induction assocsum.
            unfold mixed_sum_r.
            unfold function_on_the_sum.
            simpl.
            exact (idpath xx).
    + unfold isinternal_assoc_prod.
      intros.
      unfold internal_mult3_l . 
      unfold internal_mult3_r.
      unfold internal_mult.
      unfold function_on_the_product.
      simpl.
      unfold assoc_prod_on_types.
            unfold internal_paths_rew;
            unfold types_assoc_prod;
            simpl;
            unfold internal_paths_rew_r.
            induction assocprod.
            exact (idpath xx).
  - unfold isinternal_comm_sum, isinternal_distr, constanttypedrig_left.
    unfold isinternal_distr_r, isinternal_distr_l .
    unfold isinternal_distr_r_l, isinternal_distr_l_r.
    unfold isinternal_distr_r_r, isinternal_distr_l_l.
    unfold comm_sum_on_types.
    unfold distr_l_on_types, distr_r_on_types.
    unfold internal_paths_rew.
    unfold types_distr_r , types_distr_l.
    unfold types_commute_sum.
    unfold internal_paths_rew_r.
    split; intros.
    + induction sumcommutes.
      unfold mixed_sum_l,mixed_sum_r.
      unfold function_on_the_sum.
      exact (idpath xx).
    + split; intros.
      -- split; intros; induction distr;
         induction pr1;
            unfold mixed_sum_r,internal_mult;
            unfold function_on_the_product, function_on_the_sum;
            exact (idpath xx).
      -- split; induction distr;
         intros; induction pr2;
           unfold mixed_sum_r,mixed_sum_l,internal_mult;
           unfold function_on_the_product, function_on_the_sum;
           exact (idpath yy).
Defined.

Section BeautifulRigs.

  (* We want to define the "same" properties, but for the case in which
the rings are "beautiful", meaning that the function on the sum goes in
the opposite direction of the function on the product.
   This is supposed to match better with the sense of product and coproduct
   as universal constructions. 
   *)
  Definition theprettyrig ( œÉ : beautifulrig ) : rig.
    exact (pr1 œÉ).
  Defined.
  Coercion theprettyrig : beautifulrig >-> rig.
  Definition theprettyfunctor ( œÉ : beautifulrig ) : œÉ -> UU.
    induction œÉ. induction pr2.
    exact pr0.
  Defined.
  Coercion theprettyfunctor : beautifulrig >-> Funclass.

  Definition theprettytype { œÉ : beautifulrig } (x : œÉ) : UU.
    exact (œÉ x).
  Defined.

  Definition function_on_pretty_sum { œÉ : beautifulrig } (x y : œÉ)
    : (œÉ x) ‚®ø (œÉ y) -> œÉ ( x + y )%ring .
    induction œÉ. induction pr2.
    exact (Preamble.pr1 (pr2 x y)).
  Defined.
  Notation "x ‚ô≠ y" := (function_on_pretty_sum x y) (at level 300).
  Definition function_on_pretty_product { œÉ : beautifulrig } (x y : œÉ)
    : (œÉ x) √ó (œÉ y) <- œÉ ( x * y )%ring .
    induction œÉ. induction pr2.
    exact (Preamble.pr2 (pr2 x y)).
  Defined.
  Notation "x ‚ôØ y" := (function_on_pretty_product x y) (at level 300).

  Section BeautyUnits.
    Context {œÉ : beautifulrig}.
    
  Definition beauty0 : œÉ.
  induction œÉ.
  induction pr1.
  induction pr0.
  induction pr0.
  induction pr0.
  induction pr1.
  induction pr6.
  simpl.
  refine (unel ((pr1,, pr6),, _)).
  exact (Preamble.pr1 pr0).
  Defined.
  
  Definition beauty1 : œÉ.
  induction œÉ.
  induction pr1.
  induction pr0.
  induction pr0.
  induction pr0.
  induction pr1.
  induction pr6.
  simpl.
  refine (unel ((pr1,, pr7),, _)).
  exact pr5.
  Defined.
  End BeautyUnits.

  Notation "ùüò" := beauty0.
  Notation "ùüô" := beauty1.

  Section BeautyCharges.

  Context ( œÉ : beautifulrig).

  Definition beauty0type  := (œÉ ùüò).
  Definition beauty1type  := (œÉ ùüô).

  Definition isbeauty0empty  := (œÉ ùüò = ‚àÖ).
  Definition isbeauty1empty  := (œÉ ùüô = ‚àÖ).
  Definition isbeauty0unit  := (œÉ ùüò = unit).
  Definition isbeauty1unit  := (œÉ ùüô = unit).


  Definition isnegativelycharged  :=
    (isbeauty0empty √ó isbeauty1unit).
  Definition ispositivelycharged  : UU :=
    isbeauty0unit √ó isbeauty1empty.
  Definition isneutrallycharged  : UU :=
    œÉ ùüò = œÉ ùüô.
  End BeautyCharges.

  Definition isbeautifulrigconstant (œÉ : beautifulrig) : UU :=
    ‚àë ‚Ñµ : UU,
      ‚àè o : œÉ,
        œÉ o = ‚Ñµ.
  
  Lemma isconstant_neutral {œÉ} : isbeautifulrigconstant œÉ -> isneutrallycharged œÉ.
    unfold isbeautifulrigconstant,isneutrallycharged.
    intros.
    induction X.
    pose proof (pr2 ùüò).
    pose proof (pr2 ùüô).
    rewrite X.
    rewrite X0.
    apply idpath.
  Defined.

Definition beautiful_sum {œÉ : beautifulrig}
  {x y : œÉ}
  (xy : œÉ x ‚®ø œÉ y)
  := (x ‚ô≠ y) xy.
Definition beautiful_product {œÉ : beautifulrig}
  (x y : œÉ)
  (xy : œÉ (x * y)%ring)
  := (x ‚ôØ y) xy.
Definition beautiful_sum_r  {œÉ : beautifulrig}
  {x : œÉ}
  (xx : œÉ x)
  (y : œÉ) : œÉ (x + y)%ring
   := (x ‚ô≠ y) (inl xx : œÉ x ‚®ø œÉ y).

Definition beautiful_sum_l  {œÉ : beautifulrig}
  {y : œÉ}
  (x : œÉ)
  (yy : œÉ y) : œÉ (x + y)%ring
   := (x ‚ô≠ y) (inr yy : œÉ x ‚®ø œÉ y).

Definition beautiful_mult {œÉ : beautifulrig} 
  {x y : œÉ}
  (xy : œÉ (x * y)%ring )
  : œÉ x √ó œÉ y
    := (x ‚ôØ y) xy.

Notation "‚ôØ‚ôØ" := beautiful_mult (at level 250).
Notation "xx ‚•Ö y" := (beautiful_sum_r xx y) (at level 250).
Notation "x ‚•Ü yy" := (beautiful_sum_l x yy) (at level 250).

Definition mult_3 {œÉ : beautifulrig}
  {x y z : œÉ}
  (xyz : œÉ (x * y * z)%ring  )
  : œÉ x √ó œÉ y √ó œÉ z.
  intros.
  remember ((x * y)%ring ‚ôØ  z) as fxy_z.
  remember (fxy_z xyz) as intermediate.
  induction intermediate as [xy sz].
  remember ((x ‚ôØ y) xy).
  induction d as [sx sy].
  split; try split. exact sx. exact sy. exact sz.
Defined.

Definition mult_3_assoc {œÉ : beautifulrig}
  {x y z : œÉ}
  (xyz : œÉ (x * (y * z))%ring  )
  : œÉ x √ó œÉ y √ó œÉ z.
  intros.
  remember (x ‚ôØ  (y * z)%ring) as fx_yz.
  remember (fx_yz xyz) as intermediate.
  induction intermediate as [sx yz].
  remember ((y ‚ôØ z) yz).
  induction d as [sy sz].
  split; try split. exact sx. exact sy. exact sz.
Defined.

Definition beautiful_assoc_prod {œÉ : beautifulrig} { x y z : œÉ }
  :  œÉ ((x * y) * z)%ring  -> œÉ (x * (y * z))%ring.
  intros.
  induction œÉ.
  induction pr1.
  induction pr0.
  induction pr0.
  induction pr0.
  induction pr5.
  remember (pr5 x y z).
  unfold theprettyfunctor.
  unfold on.
  induction pr2.
  unfold op2.
  unfold op2 in p.
  simpl . simpl in p.
  rewrite <- p.
  assumption.
Defined.

Definition isbeautiful_assoc_prod (œÉ : beautifulrig) : UU :=
  ‚àè x y z : œÉ,
      ‚àè xyz : œÉ ((x * y) * z)%ring ,
        mult_3_assoc (beautiful_assoc_prod xyz)
        = mult_3 xyz.

Definition beautiful_comm_prod {œÉ : beautifulcommring} {x y : œÉ}
  : œÉ (x * y)%ring -> œÉ (y * x)%ring.
  unfold op2.
  intros.
  induction œÉ.
  induction pr1.
  induction pr0.
  unfold op2 in pr3.
  unfold iscomm in pr3.
  simpl. simpl in pr3.
  rewrite (pr3 y x).
  assumption.
Defined.
Definition swap { X Y } : X √ó Y -> Y √ó X.
  intros. induction X0.
  split. exact pr2. exact pr1.
Defined.
Definition coswap { X Y } : X ‚®ø Y -> Y ‚®ø X.
  intros. induction X0.
  right. exact a.
  left. exact b.
Defined.

Definition isbeautiful_comm_prod (œÉ : beautifulcommring) : UU :=
  ‚àè x y : œÉ,
      ‚àè xy : œÉ ( x * y)%ring ,
        swap (‚ôØ‚ôØ xy) = ‚ôØ‚ôØ (beautiful_comm_prod xy). 

Definition beautiful_comm_sum {œÉ : beautifulrig} {x y : œÉ}
                              : œÉ (x + y)%ring -> œÉ (y + x)%ring.
  unfold op1.
  intros.
  induction œÉ.
  induction pr1.
  induction pr0.
  induction pr0.
  induction pr0.
  induction pr0.
  unfold op1 in pr6.
  simpl . simpl in pr6.
  rewrite (pr6 y x).
  assumption.
Defined.

Definition beautiful_assoc_sum {œÉ : beautifulrig } {x y z : œÉ}
  : œÉ (x + y + z)%ring  ->  œÉ (x + (y + z))%ring  .
  intros.
  induction œÉ.
  induction pr1. repeat induction pr0.
  unfold op1 in pr0. unfold op1.
  simpl in pr0. simpl.
  rewrite <- (pr0 x y z).
  assumption.
Defined.

Definition beautiful_assoc_sum_rightright (œÉ : beautifulrig) : UU :=
  ‚àè x y z : œÉ,
      ‚àè xx : œÉ x,
        beautiful_assoc_sum (
            (xx ‚•Ö y) ‚•Ö z) =
          (xx ‚•Ö (y + z)%ring ).

Definition beautiful_assoc_sum_leftright (œÉ : beautifulrig) : UU :=
  ‚àè x y z : œÉ,
      ‚àè yy : œÉ y,
       beautiful_assoc_sum ( 
       (x ‚•Ü yy) ‚•Ö z) =
       (x ‚•Ü (yy ‚•Ö z)).

Definition beautiful_assoc_sum_leftleft (œÉ : beautifulrig) : UU :=
  ‚àè x y z : œÉ,
      ‚àè zz : œÉ z,
       beautiful_assoc_sum ( 
       (x + y)%ring ‚•Ü zz) =
       (x ‚•Ü (y ‚•Ü zz)).

Definition isbeautiful_assoc_sum (œÉ : beautifulrig) : UU :=
  beautiful_assoc_sum_leftleft œÉ
√ó beautiful_assoc_sum_leftright œÉ
√ó beautiful_assoc_sum_rightright œÉ.

Definition isbeautifully_associative (œÉ : beautifulrig) : UU :=
  isbeautiful_assoc_sum œÉ √ó isbeautiful_assoc_prod œÉ.

Definition beautiful_distr_l {œÉ : beautifulrig} (x y z : œÉ):
      œÉ (x * (y + z))%ring = œÉ (x * y + x * z)%ring .
induction œÉ as [rig [on rest]].
induction rig.
induction pr1 as [set [plus times]].
simpl in on.
induction pr2.
rename pr2 into distr.
unfold isdistr in distr.
induction distr as [ldistr rdistr].
remember (ldistr y z x).
unfold op1, op2.
unfold op1, op2 in p.
simpl. simpl in p.
rewrite p;apply idpath.
Defined.

Definition beautifully_distr_l {œÉ : beautifulrig} {x y z : œÉ}:
      œÉ (x * (y + z))%ring -> œÉ (x * y + x * z)%ring .
  rewrite beautiful_distr_l.
  exact (idfun _).
Defined.
Definition beautifully_factor_l {œÉ : beautifulrig} {x y z : œÉ} :
  œÉ (x * y + x * z)%ring  -> œÉ (x * (y + z))%ring .
  rewrite beautiful_distr_l.
  exact (idfun _).
Defined.

Definition beautiful_distr_r {œÉ : beautifulrig} ( x y z : œÉ ):
      œÉ ((y + z) * x)%ring = œÉ (y * x + z * x)%ring .
induction œÉ as [rig [on rest]].
induction rig.
induction pr1 as [set [plus times]].
simpl in on.
induction pr2.
rename pr2 into distr.
unfold isdistr in distr.
induction distr as [ldistr rdistr].
remember (rdistr y z x).
unfold op1, op2.
unfold op1, op2 in p.
simpl; simpl in p.
rewrite p;apply idpath.
Defined.
Definition beautifully_distr_r {œÉ : beautifulrig} {x y z : œÉ}:
      œÉ ((y + z) * x)%ring -> œÉ (y * x + z * x)%ring .
  rewrite beautiful_distr_r.
  exact (idfun _).
Defined.

Check beautiful_sum.
Definition isbeautiful_distr_left_up (œÉ : beautifulrig) : UU :=
  ‚àè x y z : œÉ,
      ‚àè xyz : œÉ (x * (y + z))%ring,
      ‚àë xy_or_xz : œÉ (x * y)%ring ‚®ø œÉ (x * z)%ring,
          beautiful_sum xy_or_xz
          =
          beautifully_distr_l xyz.
Definition isbeautiful_distr_left_down (œÉ : beautifulrig) : UU :=
  ‚àè x y z : œÉ,
    ‚àè xy_or_xz : œÉ (x * y)%ring ‚®ø œÉ (x * z)%ring,
      ‚àë xyz : œÉ (x * (y + z))%ring,
          beautiful_sum xy_or_xz
          =
          beautifully_distr_l xyz.
Definition isbeautiful_distr_right_up (œÉ : beautifulrig) : UU :=
  ‚àè x y z : œÉ,
      ‚àè xyz : œÉ ((x + y) * z)%ring,
      ‚àë xz_or_yz : œÉ (x * z)%ring ‚®ø œÉ (y * z)%ring,
          beautiful_sum xz_or_yz
          =
          beautifully_distr_r xyz.
Definition isbeautiful_distr_right_down (œÉ : beautifulrig) : UU :=
  ‚àè x y z : œÉ,
    ‚àè xy_or_xz : œÉ (x * y)%ring ‚®ø œÉ (x * z)%ring,
      ‚àë xyz : œÉ (x * (y + z))%ring,
          beautiful_sum xy_or_xz
          =
          beautifully_distr_l xyz.
Definition isbeautiful_distr_left (œÉ : beautifulrig) : UU :=
  isbeautiful_distr_left_down œÉ √ó
  isbeautiful_distr_left_up œÉ.

Definition isbeautiful_distr_right (œÉ : beautifulrig) : UU :=
  isbeautiful_distr_right_down œÉ √ó
  isbeautiful_distr_right_up œÉ.

Definition isbeautiful_distr_up (œÉ : beautifulrig) : UU :=
  isbeautiful_distr_left_up œÉ √ó
  isbeautiful_distr_right_up œÉ.

Definition isbeautiful_distr_down (œÉ : beautifulrig) : UU :=
  isbeautiful_distr_left_down œÉ √ó
  isbeautiful_distr_right_down œÉ.

Definition isbeautiful_distr (œÉ : beautifulrig) : UU :=
  isbeautiful_distr_left œÉ √ó isbeautiful_distr_right œÉ.

Definition isbeautiful_comm_sum (œÉ : beautifulrig) : UU :=
  ‚àè x y : œÉ,
     beautiful_comm_sum ‚àò (x ‚ô≠ y) = (y ‚ô≠ x) ‚àò coswap.
  
Definition beautyrig : UU :=
  ‚àë œ° : beautifulrig,
      isbeautifully_associative œ°
   √ó  isbeautiful_comm_sum œ°
   √ó  isbeautiful_distr œ°.

Section beautyrigs.
  Definition beautyrig_to_beautifulrig: beautyrig -> beautifulrig.
    exact pr1.
  Defined.
  Coercion beautyrig_to_beautifulrig: beautyrig >-> beautifulrig.

  Definition beautyring : UU :=
    ‚àë œ° : beautifulring,
      isbeautifully_associative œ°
   √ó  isbeautiful_comm_sum œ°
   √ó  isbeautiful_distr œ°.

  Definition beautyring_to_beautyrig : beautyring -> beautyrig.
    intros; induction X.
    exists pr1.
    exact pr2.
  Defined.
  Coercion beautyring_to_beautyrig : beautyring >-> beautyrig.

  Definition beautycommring : UU :=
    ‚àë œ° : beautifulcommring,
      isbeautifully_associative œ°
   √ó  isbeautiful_comm_sum œ°
   √ó  isbeautiful_comm_prod œ° (* the additional requirement *)
   √ó  isbeautiful_distr œ°.

  Definition beautycommring_to_beautyring : beautycommring -> beautyring.
    intros; induction X.
    exists pr1.
    split; induction pr2.
    - exact pr0.
    - induction pr2. induction pr3.
      split. exact pr2. exact pr4.
  Defined.

  Coercion beautycommring_to_beautyring : beautycommring >-> beautyring.

  Context {œ° : beautifulrig}.
  Context {Œ± Œ≤ ‚Ñµ ‚Ñ∂: œ°}.

  Definition beautiful_fibers (data : œ° Œ± √ó œ° Œ≤) : UU
    := ‚àë x : œ° (Œ± * Œ≤)%ring, ‚ôØ‚ôØ x = data.
  Definition beautiful_cofibers_left (data : œ° (Œ± + Œ≤)%ring) : UU
    := ‚àë aa : œ° Œ±, (aa ‚•Ö Œ≤) = data.
  Definition beautiful_cofibers_right (data : œ° (Œ± + Œ≤)%ring) : UU
    := ‚àë bb : œ° Œ≤, (Œ± ‚•Ü bb) = data.
   
  (* I think this is  what makes beautiful rings beautiful. *)
  Definition raise_beautifully
    (path : œ° Œ± √ó œ° Œ≤ -> œ° ‚Ñµ ‚®ø œ° ‚Ñ∂) : œ° (Œ± * Œ≤)%ring -> œ° (‚Ñµ + ‚Ñ∂)%ring .  
    intro ab.
    remember (‚ôØ‚ôØ ab) as aandb.
    remember (path aandb) as alephorbeth.
    exact ((‚Ñµ ‚ô≠ ‚Ñ∂) alephorbeth).
  Defined.
  Definition lower_beautifully
    (path : œ° (Œ± * Œ≤)%ring <- œ° (‚Ñµ + ‚Ñ∂)%ring )  
    : œ° Œ± √ó œ° Œ≤ <- œ° ‚Ñµ ‚®ø œ° ‚Ñ∂.
    intro alephorbeth.
    remember ((‚Ñµ ‚ô≠ ‚Ñ∂) alephorbeth) as lflat.
    remember (path lflat) as wflat.
    exact (‚ôØ‚ôØ wflat).
  Defined.
  (* In particular, logical equivalences factor through the ring  *)
  Definition combine_beautifully
    (path :
    
    

                               
        





    
    

  

          
        
    

